<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>destructuring.html</title>
    <script>
        //如果解构不成功，变量的值就等于undefined。
        let [foo, [[bar], baz]] = [1, [[2], 3]];
        foo // 1
        bar // 2
        baz // 3

        let [ , , third] = ["foo", "bar", "baz"];
        third // "baz"

        let [x, , y] = [1, 2, 3];
        x // 1
        y // 3

        let [head, ...tail] = [1, 2, 3, 4];
        head // 1
        tail // [2, 3, 4]

        let [x, y, ...z] = ['a'];
        x // "a"
        y // undefined
        z // []
    </script>
    <script>
        // 报错
        let [foo] = 1;
        let [foo] = false;
        let [foo] = NaN;
        let [foo] = undefined;
        let [foo] = null;
        let [foo] = {};
        //上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。
    </script>
    <script>
        //默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
        let [x = 1, y = x] = [];     // x=1; y=1
        let [x = 1, y = x] = [2];    // x=2; y=2
        let [x = 1, y = x] = [1, 2]; // x=1; y=2
        let [x = y, y = 1] = [];     // ReferenceError
    </script>
    <script>
        //第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。
        //第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。
        let { bar, foo } = { foo: "aaa", bar: "bbb" };
        foo // "aaa"
        bar // "bbb"

        let { baz } = { foo: "aaa", bar: "bbb" };
        baz // undefined
    </script>
    <script>
        //字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。
        const [a, b, c, d, e] = 'hello';
        a // "h"
        b // "e"
        c // "l"
        d // "l"
        e // "o"
    </script>
</head>
<body>

</body>
</html>